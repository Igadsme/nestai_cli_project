# nestai/codegen.py
from __future__ import annotations

from textwrap import dedent


def generate_code(final_prompt: str) -> str:
    """
    Deterministic, secure-by-default code generator.

    For hackathon purposes this returns a high-quality, secure Python
    login API template that you can show to judges. It does not call
    any external API and is fully deterministic/stable.

    `final_prompt` is embedded into the module docstring so you can
    see what requirement produced this code.
    """

    code = dedent(
        f'''
        """
        Generated by NestAI Secure Code Pipeline.

        Final secure prompt:
        {final_prompt}
        """

        from __future__ import annotations

        import hashlib
        import hmac
        import os
        from datetime import datetime, timedelta
        from typing import Dict, Optional

        from fastapi import FastAPI, Depends, HTTPException, status
        from fastapi.security import OAuth2PasswordRequestForm
        from pydantic import BaseModel, EmailStr, constr

        # In a real system, use passlib or bcrypt/argon2.
        # Here we keep a simple, clear example.

        PASSWORD_SALT = os.getenv("NESTAI_DEMO_SALT", "change-me-demo-salt").encode("utf-8")


        def _hash_password(password: str) -> str:
            return hashlib.pbkdf2_hmac(
                "sha256",
                password.encode("utf-8"),
                PASSWORD_SALT,
                200_000,
            ).hex()


        class User(BaseModel):
            email: EmailStr
            hashed_password: str
            is_active: bool = True


        class UserCreate(BaseModel):
            email: EmailStr
            password: constr(min_length=8)


        class Token(BaseModel):
            access_token: str
            token_type: str = "bearer"


        app = FastAPI(title="NestAI Secure Login Demo")

        # In-memory "database" just for demo.
        _USERS: Dict[str, User] = {{}}


        def _verify_password(plain: str, hashed: str) -> bool:
            expected = _hash_password(plain)
            # constant-time comparison
            return hmac.compare_digest(expected, hashed)


        def _create_access_token(email: str) -> str:
            # For the demo, we return a simple opaque token.
            # In production, use JWT with proper signing & expiry.
            now = datetime.utcnow()
            expires = now + timedelta(minutes=30)
            token = f"demo-token:{email}:{int(expires.timestamp())}"
            return token


        @app.post("/register", response_model=User, status_code=status.HTTP_201_CREATED)
        def register(user_in: UserCreate) -> User:
            if user_in.email in _USERS:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="User already exists.",
                )

            user = User(
                email=user_in.email,
                hashed_password=_hash_password(user_in.password),
            )
            _USERS[user.email] = user
            return user


        @app.post("/login", response_model=Token)
        def login(form_data: OAuth2PasswordRequestForm = Depends()) -> Token:
            user: Optional[User] = _USERS.get(form_data.username)
            if not user or not user.is_active:
                # Generic error message â€“ no user enumeration
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid credentials.",
                )

            if not _verify_password(form_data.password, user.hashed_password):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid credentials.",
                )

            token = _create_access_token(user.email)
            return Token(access_token=token)


        @app.get("/health")
        def healthcheck() -> Dict[str, str]:
            return {{"status": "ok", "service": "nestai-secure-login-demo"}}
        '''
    ).strip("\n")

    return code
